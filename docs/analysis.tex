\chapter{Аналитический раздел}

\section{Постановка задачи}

В соответствии с техническим заданием на курсовую работу, необходимо исследовать распределение памяти в многопоточных приложениях Linux. 

Для решения поставленной задачи необходимо:
\begin{enumerate}
	\item Провести анализ стандартного аллокатора памяти.
	\item Провести анализ системных вызовов выделения памяти.
	\item Провести анализ и выбрать метод перехвата системных вызовов.
	\item Разработать алгоритмы перехвата системных вызовов и вывода данных о потреблении процессом памяти.
	\item Разработать загружаемый модуль ядра, реализующий поставленную задачу.
	\item Разработать тестовые однопоточные и многопоточные программы для исследования выделения памяти.
	\item Исследовать выделение памяти для многопоточных приложений.
\end{enumerate}

\section{Анализ стандартных функций распределения памяти}

Функция \code{malloc()} библиотеки glibc выделяет память из кучи и при необходимости регулирует размер кучи с помощью функции \code{sbrk()}, которая является оберткой системного вызова \code{brk}. Куча является виртуальной, то есть располагается в виртуальном адресном пространстве процесса. При выделении блоков памяти размером больше \code{MMAP\_THRESHOLD} байтов память выделяется как анонимное отображение с помощью системного вызова \code{mmap}. \code{MMAP\_THRESHOLD} по умолчанию равен 128 килобайтам, но может быть изменен с помощью \code{mallopt()}.

Память освобождается путем вызова функции \code{free()}, которая выполняет системный вызов \code{brk} или \code{munmap}.

\section{Анализ системных вызовов brk, mmap и munmap}

Размер сегмента данных адресного пространства процесса управляется системными вызовами \code{brk}, \code{mmap} и \code{munmap} (см. листинг~\ref{lst:brkmmap}).

\lstinputlisting[caption={Прототипы системных вызовов \code{brk}, \code{mmap} и \code{munmap}}, label={lst:brkmmap}, language=C]{inc/code/brk_mmap.c}

Вызов \code{brk} устанавливает разрыв программы (program break) в значение, указанное в аргументе \code{addr}. Разрыв программы --- это адрес первого байта, расположенного после сегмента данных процесса. Таким образом, увеличение разрыва программы позволяет выделить память в куче, а уменьшение --- освободить. Функция \code{sbrk()} является оберткой функции \code{brk}, не считается системным вызовом и позволяет увеличивать сегмент данных на указанное в аргументе количество байтов.

Вызов \code{mmap} отображает \code{length} байтов, начиная со смещения \code{offset} в файле, определенного файловым дескриптором \code{fd}, в память, начиная с адреса \code{addr}. Возвращает \code{mmap} указатель на отображенные данные. Начиная с ядра версии 2.4 поддерживается флаг \code{MAP\_ANONYMOUS}, позволяющий реализовывать анонимные отображения. Анонимное отображение --- это отображение пространства виртуальной памяти процесса, а не файла в пространстве файловой системы. Анонимные отображения не являются частью стандарта POSIX, однако реализованы во многих системах.

Вызов \code{munmap} удаляет отображение в память по адресу \code{addr} размера \code{lenght}.

Адресное пространство процесса описывается в ядре с помощью структуры \code{mm\_struct}, которая называется дескриптором памяти и определена в \code{<linux/mm\_types.h>}. Некоторые поля структуры \code{mm\_struct} представлены на листинге~\ref{lst:mmstruct}.

\lstinputlisting[caption={Структура \code{mm\_struct}}, label={lst:mmstruct}, language=C]{inc/code/mm_struct.h}

Структура \code{vm\_area\_struct} описывает область памяти процесса и является двусвязным списком. На листинге~\ref{lst:vmareastruct} представлены некоторые поля этой структуры.

\lstinputlisting[caption={Структура \code{vm\_area\_struct}}, label={lst:vmareastruct}, language=C]{inc/code/vm_area_struct.h}

Размер области памяти можно определить как разность \code{vm\_end} и \code{vm\_start}. При этом если \code{vma->vm\_start <= mm->brk \&\& vma->vm\_end >= mm->start\_brk}, где \code{vma} --- рассматриваемая области памяти, \code{mm} --- рассматриваемое адресное пространство, то данная область памяти является кучей. Если \code{vma->vm\_start <= mm->start\_stack \&\& vma->vm\_end >= mm->start\_stack}, то данная область памяти является стеком. Если \code{vma->anon\_vma != NULL \&\& vma->vm\_file == NULL}, то область памяти является анонимным отображением.

\section{Методы перехвата системных вызовов}

\subsection{Сплайсинг}

Сплайсинг --- метод перехвата системных вызовов путем добавления инструкций безусловного перехода для встраивания собственного кода в оригинальный системный вызов. Реализуется метод на языке ассемблера.

Из преимуществ данного метода можно отметить отсутствие специальных требований к ядру и минимальные накладные расходы на перехват. Главный недостаток --- высокая сложность реализации.

\subsection{Модификация таблицы системных вызовов}

Данный метод заключается в замене адреса перехватываемого системного вызова в таблице системных вызовов на адрес некоторой функции-перехватчика, которая кроме собственно системного вызова выполняет ряд других необходимых в рамках поставленной задачи операций (например, журналирование).

Для перехвата необходимо экспортировать таблицу системных вызовов, определить указатель для сохранения оригинального вывоза, реализовать собственный системный вызов, во время инициализации загружаемого модуля сохранить указатель на оригинальный вызов, заменить адрес вызова в системной таблице. При выгрузке модуля необходимо восстановить адрес оригинального вызова. На листинге~\ref{lst:mkdir} представлен пример перехвата вызова \code{mkdir} --- реализованная функция не выполняет оригинальный вызов и возвращает нуль.

\lstinputlisting[caption={Перехват системного вызова \code{mkdir} (ядро версии 2.4.22)}, label={lst:mkdir}, language=C]{inc/code/mkdir.c}

Начиная с ядра версии 2.5.41 символ \code{sys\_call\_table} более не экспортируется, так как возможность замены адресов вызовов в системной таблице является потенциально опасной.
Для определения адреса таблицы системных вызовов в ядрах 2.6 и новее следует рассмотреть файл \code{/proc/kallsyms}, содержащий адреса всех символов ядра. Получить адрес искомой таблицы можно выполнив команду \code{\# cat /proc/kallsyms | grep "\ sys\_call\_table"}. Адрес таблицы позволит определить адреса оригинальных системных вызовов и выполнить необходимые замены.

\subsection{Linux Security Modules}

Linux Security Modules --- фреймворк для разработки модулей безопасности ядра Linux. Начиная с ядра версии 2.6 LSM является частью ядра. На основе LSM разработаны AppArmor, SELinux и некоторые другие модули безопасности.

Для некоторых системных вызовов фреймворк реализует функции-перехватчики, в которые возможно встраивать собственный код. Это позволяет работать с системными вызовами без необходимости модификации системной таблицы.

Для перехвата \code{mkdir} следует в директории \code{/security} создать поддиректорию для модуля и исходный код модуля (см. листинг~\ref{lst:lsmc}). Макрос \code{LSM\_HOOK\_INIT} регистрирует соответствие \code{foobar\_inode\_mkdir()} функции-перехватчику \code{inode\_mkdir()}, а \code{security\_add\_hooks()} добавляет функцию в общий список пользовательских функций-перехватчиков LSM. Далее необходимо добавить заголовок пользовательской функции-перехватчика в файл \code{/include/linux/lsm\_hooks.h} (см. листинг~\ref{lst:lsmh}).

\lstinputlisting[caption={Функция-перехватчик \code{mkdir}}, label={lst:lsmc}, language=C]{inc/code/lsm.c}

\lstinputlisting[caption={Регистрация функции-перехватчика \code{mkdir}}, label={lst:lsmh}, language=C]{inc/code/lsm.h}

Достоинство данного метода заключается в возможности более безопасной работы с кодом ядра. Среди недостатков данного метода: необходимость пересборки ядра, ограничение в один модуль безопасности. Главной задачей фреймворка LSM остается реализация дополнительных проверок прав доступа.

\section{Вывод}

В результате анализа особенностей работы стандартного аллокатора памяти было установлено, что аллокатор для выделения памяти использует системные вызовы \code{brk} и \code{mmap}.

В результате анализа системных вызовов были определены их назначения, особенности реализации, особенности описания адресного пространства процесса в ядре операционной системы Linux.

В качестве метода для перехвата системных вызовов был выбран метод модификации системной таблицы, как наиболее гибкий в условиях поставленной задачи и не требующий реализации на языке ассемблера.
