\chapter{Исследовательский раздел}

\section{Технические характеристики системы}

Исследование распределения памяти проводилось на компьютере со следующими характеристиками:

\begin{itemize}
	\item Процессор Intel Core i5-6200U.
	\item Оперативная память объемом 6 Гб.
	\item Операционная система Linux (дистрибутив Ubuntu 20.10 x86-64, ядро версии 5.8.0)
\end{itemize}

\section{Исследование распределения памяти}

Для исследования распределения памяти был разработан набор однопоточных и многопоточных приложений. В данном случае рассматриваются ситуации, при которых потоки завершаются без освобождения памяти. Так как владельцем ресурсов является процесс, выделенная потоку память не возвращается системе до завершения процесса или пока процесс не освободит эту память.

На языке Python разработана программа анализа данных, полученных из загружаемого модуля ядра. Программа получает на вход файл, содержащий часть журнала ядра, строит графики зависимости потребления памяти (куча, стек и анонимные отображения) от времени, рассчитывает максимальное и среднее потребление памяти. Для построения графиков и для расчета статистической информации применяются модули matplotlib и numpy соответственно.

\subsection{Программа с одним выделением памяти}

Рассмотрим программы на листингах \ref{lst:11} и \ref{lst:12}. Первая программа выделяет память объемом 128 байтов в основном потоке. Вторая программа выделяет 128 байтов, после чего создает новый поток, который сразу же завершается.

Не смотря на то, что наименьшей адресуемой единицей памяти являются байт и машинное слово, единицей управления памятью в ядре является страница.Размер страницы для 32-разрядное системы обычно составляет 4 килобайта, для 64-разрядной --- 8 килобайтов. Таким образом, при запрашивании 128 байтов аллокатор выделяет одну страницу.

\lstinputlisting[caption={\code{1.c}}, label={lst:11}, language=C]{inc/code/tests/simple_thread/1.c}

\lstinputlisting[caption={\code{2.c}}, label={lst:12}, language=C]{inc/code/tests/simple_thread/2.c}

Графики потребления памяти представлены на рисунке \ref{img:1}.

Во второй программе увеличилось максимальное потребление памяти анонимных отображений на 20~килобайтов. Кроме того, на 33\% (на 3.67~килобайта) увеличилось среднее потребление памяти кучи. При этом потребление памяти стека остается неизменным.

\imgwc{h}{\textwidth}{1}{Графики потребления памяти}

\subsection{Программа с тремя выделениями памяти}

Рассмотрим программы аналогичные предыдущим, за исключением того, что выделение 128~байтов происходит три раза в случае однопоточной программы, два раза в главном потоке и один раз в созданном потоке в случае многопоточной программы.

Графики потребления памяти представлены на рисунке \ref{img:2}.

\imgwc{h}{\textwidth}{2}{Графики потребления памяти}

Полученный результат идентичен результатам предыдущих тестовым программам. Таким образом, выделение памяти в дочернем потоке не отражается на потреблении памяти. Потребление памяти стека также не изменилось. Несмотря на то, что одно из выделений памяти происходит в дочернем процессе, дополнительная страница не выделяется.

\subsection{Программа с двенадцатью выделениями памяти}

Увеличим объемы выделяемой памяти. В первой программе последовательно выделим 128, 256, 512, 1024, 2048, 4096~байтов, затем еще 8, 32, 128, 512, 2048, 4096~килобайтов. Во второй программе каждое выделение памяти произведем в отдельном потоке. Таким образом, будет создано 12 потоков.

Графики потребления памяти представлены на рисунке \ref{img:3}.

Время выполнения второй программы увеличилось более чем в 2 раза, по сравнению с первой программой. Это связано с временн\textit{ы}ми затратами на создание потоков.

Максимальное потребление памяти кучи в первой и второй программах не отличаются. При этом максимальное потребление памяти анонимных отображений во второй программе увеличилось более чем в 13 раз по сравнению с первой программой. Потребление памяти стека осталось неизменным. Таким образом, можно сделать вывод, что распределение памяти в данном многопоточном приложении выполняется намного менее эффективно в сравнении с однопоточным аналогом. Можно предположить, что с увеличением объемов приложения объем нерационально израсходованной памяти будет увеличиваться. Можно сделать вывод о том, что выделение памяти в 12 потоках приводит к выделению дополнительных страниц, по сравнению с выделение такого же объема памяти в однопоточной программе.

\imgwc{h}{\textwidth}{3}{Графики потребления памяти}

\section{Вывод}

В результате исследования набора тестовых однопоточных и многопоточных программ было установлено, что создание одного потока увеличивает среднее потребление памяти кучи на 3.67~килобайта и максимальное потребление памяти анонимных отображений на 20~килобайтов. Потребление памяти не зависит от места выделения памяти малых объемов при работе с одним дочерним потоком.

С увеличением количества дочерних потоков растет потребление памяти анонимных отображений, из чего можно сделать вывод о том, что выделение областей памяти объемом более 128~килобайт в разных потоках приводит к многократным вызовам \code{mmap}, выделению дополнительных страниц и неэффективному использованию памяти. При этом потребление памяти кучи изменяется незначительно.