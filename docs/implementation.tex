\chapter{Технологический раздел}

\section{Выбор языка программирования и среды разработки}

В качестве языка программирования был выбран язык C, как наиболее предпочтительный при разработке загружаемых модулей ядра Linux. Для сборки загружаемого модуля была выбрана утилита make.

В качестве среды разработки была выбрана программа CLion, разрабатываемая компанией JetBrains. CLion содержит редактор кода, отладчик, средства для статического анализа кода, средства для сборки проекта.

\section{Описание структур данных}

Для описания функций-перехватчиков в загружаемом модуле требуется структура данных, содержащая указатель на таблицу системных вызовов, указатели на начало и конец списка функций-перехватчиков.

Каждая функция-перехватчик описывается структурой (списком), содержащей идентификатор системного вызова, указатель на оригинальный системный вызов, указатель на функцию-перехватчик, указатель на следующую структуру. В условиях поставленной задачи можно ограничиться односвязным списком. При инициализации новой функции следует добавить в конец списка новый элемент, выделив под него память.

\section{Реализация загружаемого модуля ядра}

На листинге~\ref{lst:makefile} Приложения А представлен Makefile загружаемого модуля ядра. Кроме непосредственно сборки модуля Makefile содержит цели \code{install}, \code{uninstall} и \code{clean}, которые позволяют загрузить, выгрузить модуль и очистить директорию от файлов сборки.

Для загрузки модуля необходимо определить адрес таблицы системных вызовов. В данном случае используется команда \code{\# cat /proc/kallsyms | grep "\ sys\_call\_table"}. Затем извлекается первое полученное в результате выполнения команды значение. Полученный адрес передается в модуль в качестве параметра \code{syscall\_table\_addr} при исполнении команды \code{\# insmod ./matrace.ko}.

Для выгрузки модуля выполняется команда \code{\# rmmod matrace}.

Разработаны необходимые структуры данных (см. листинг \ref{lst:struct}).

\lstinputlisting[caption={Структуры данных}, label={lst:struct}, language=C, linerange={8-22}]{../matrace/module/sys_hook.h}

При загрузке модуля, то есть в функции \code{md\_init()}, вызывается функция \code{addr\_to\_pointer()}, возвращающая адрес таблицы системных вызовов. Далее инициализируется структура \code{sys\_hook}. Вызывается функция \code{add\_hooks()}, которая содержит вызовы функций, инициализирующие функции-перехватчики для \code{brk}, \code{mmap} и \code{munmap}. Функции-перехватчики описаны в файле \code{hook.c}. На листинге~\ref{lst:brkhook} представлена функция-перехватчик \code{brk}. Модификатор \code{asmlinkage} сообщает компилятору, что функция не должна ожидать найти свои аргументы в регистрах процессора. \code{sys\_brk\_t} --- тип данных, определенный в файле \code{hooks.h} и являющийся указателем на системный вызов.

\lstinputlisting[caption={Функция-перехватчик brk}, label={lst:brkhook}, language=C, linerange={5-13}]{../matrace/module/hooks.c}

Функция \code{log\_vma()} печатает в журнал ядра суммарный размер областей памяти кучи, стека и анонимных отображений. Каждый системный вызов \code{brk}, \code{mmap} и \code{munmap} сопровождается записью в следующем формате: \code{[<время>] <название модуля>: <pid вызывающего процесса>: <системный вызов> <размер кучи> <размер стека> <размер анонимных отображений>}.

При выгрузке модуля, то есть в функции \code{md\_exit()}, вызывается функция \code{sys\_hook\_free()}, освобождающая память, выделенная под структуру (список) \code{sys\_hook\_ent} и структуру \code{sys\_hook}, затем таблица системных вызовов возращается в исходное состояние.

После завершения процесса, требующего исследования, необходимо прочитать системный журнал и отфильтровать его по искомому pid. Для получения pid процесса можно запустить программу командой \code{\$ ./a.out \& \$!}. Для получения всех записей  исследуемого процесса необходимо выполнить команду \code{\# dmesg | grep "matrace: <pid>:"}. На листинге~\ref{lst:trace} представлен пример результата.

\lstinputlisting[caption={Результат трассировки процесса 71077}, label={lst:trace}]{inc/code/trace.txt}

На листингах~\ref{lst:logh}--\ref{lst:modulec} Приложения А представлен исходный код загружаемого модуля ядра.

\section{Тестирование и отладка загружаемого модуля ядра}

Отладка загружаемого модуля ядра с использованием стандартных средств невозможна. В процессе разработки использовалась отладочная печать в журнал ядра: \code{printk(KERN\_DEBUG ``matrace: \%s $\backslash$n``, debug\_info)}. В журнал выводились требующие отладки переменные, что позволяло локализовывать ошибки и исправлять их.

Разработанное программное обеспечение было протестировано в полном объеме, найденные ошибки были устранены.

\section{Вывод}

В результате разработки загружаемого модуля ядра получено программное обеспечение позволяющее осуществлять мониторинг распределения памяти.